<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Language Mechanics On Memory ProfilingAuthor: William KennedyJune 1, 2017  原文地址 ：Language Mechanics On Memory Profiling 前言本系列文章总共四篇，主要帮助大家理解 Go 语言中一些语法结构和其背后的设计原则，包括指针、栈、堆、逃逸分析和值&#x2F;指针传递。这是第三篇，主要介绍 Go 语言">
<meta property="og:type" content="article">
<meta property="og:title" content="GoLanguageMechanicsOnMemoryProfiling">
<meta property="og:url" content="http://yoursite.com/2020/06/26/Go/Translation/GoLanguageMechanicsOnMemoryProfiling/index.html">
<meta property="og:site_name" content="hei">
<meta property="og:description" content="Language Mechanics On Memory ProfilingAuthor: William KennedyJune 1, 2017  原文地址 ：Language Mechanics On Memory Profiling 前言本系列文章总共四篇，主要帮助大家理解 Go 语言中一些语法结构和其背后的设计原则，包括指针、栈、堆、逃逸分析和值&#x2F;指针传递。这是第三篇，主要介绍 Go 语言">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-06-26T06:19:56.000Z">
<meta property="article:modified_time" content="2020-06-26T06:24:06.536Z">
<meta property="article:author" content="Hei">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/06/26/Go/Translation/GoLanguageMechanicsOnMemoryProfiling/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>GoLanguageMechanicsOnMemoryProfiling | hei</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hei</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/26/Go/Translation/GoLanguageMechanicsOnMemoryProfiling/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hei">
      <meta itemprop="description" content="心里有梦，眼里有光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          GoLanguageMechanicsOnMemoryProfiling
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-26 14:19:56 / 修改时间：14:24:06" itemprop="dateCreated datePublished" datetime="2020-06-26T14:19:56+08:00">2020-06-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Language-Mechanics-On-Memory-Profiling"><a href="#Language-Mechanics-On-Memory-Profiling" class="headerlink" title="Language Mechanics On Memory Profiling"></a>Language Mechanics On Memory Profiling</h1><p align="right">Author: William KennedyJune 1, 2017</p>

<p>原文地址 ：<a href="https://www.ardanlabs.com/blog/2017/06/language-mechanics-on-memory-profiling.html" target="_blank" rel="noopener">Language Mechanics On Memory Profiling</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列文章总共四篇，主要帮助大家理解 Go 语言中一些语法结构和其背后的设计原则，包括指针、栈、堆、逃逸分析和值/指针传递。这是第三篇，主要介绍 Go 语言机制之内存剖析。（译者注：这一篇可看成第二篇的进阶版）</p>
<a id="more"></a>

<p>以下是本系列文章的索引：</p>
<ol>
<li>Language Mechanics On Stacks And Pointers</li>
<li>Language Mechanics On Escape Analysis</li>
<li>Language Mechanics On Memory Profiling</li>
<li>Design Philosophy On Data And Semantics</li>
</ol>
<p>观看这段示例代码的视频演示：<a href="https://engineers.sg/video/go-concurrency-live-gophercon-sg-2017--1746" target="_blank" rel="noopener">GopherCon Singapore (2017) - Escape Analysis</a></p>
<h2 id="介绍（Introduction）"><a href="#介绍（Introduction）" class="headerlink" title="介绍（Introduction）"></a>介绍（Introduction）</h2><p>在前面的博文中，通过一个共享在<code>goroutine</code>的栈上的值的例子讲解了逃逸分析的基础。还有其他没有介绍的造成值逃逸的场景。为了帮助大家理解，我将调试一个分配内存的程序，并使用非常有趣的方法。</p>
<h2 id="程序（The-Program）"><a href="#程序（The-Program）" class="headerlink" title="程序（The Program）"></a>程序（The Program）</h2><p>我想了解<code>io</code>包，所以我创建了一个简单的项目。给定一个字符序列，写一个函数，可以找到字符串<code>elvis</code>并用大写开头的<code>Elvis</code>替换它。我们正在讨论国王（<code>Elvis</code>即猫王，摇滚明星），他的名字总是大写的。</p>
<p>这是一个解决方案的链接：<a href="https://play.golang.org/p/n_SzF4Cer4" target="_blank" rel="noopener">https://play.golang.org/p/n_SzF4Cer4</a></p>
<p>这是一个压力测试的链接：<a href="https://play.golang.org/p/TnXrxJVfLV" target="_blank" rel="noopener">https://play.golang.org/p/TnXrxJVfLV</a></p>
<p>代码列表里面有两个不同的函数可以解决这个问题。这篇博文将会关注（其中的）<code>algOne</code>函数，因为它使用到了<code>io</code>库。你可以自己用下<code>algTwo</code>，体验一下内存，CPU 消耗的差异。</p>
<h3 id="Listing-1"><a href="#Listing-1" class="headerlink" title="Listing 1"></a>Listing 1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">abcelvisaElvisabcelviseelvisaelvisaabeeeelvise l v i saa bb e l v i saa elvi</span><br><span class="line">selvielviselvielvielviselvi1elvielviselvis</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">abcElvisaElvisabcElviseElvisaElvisaabeeeElvise l v i saa bb e l v i saa elvi</span><br><span class="line">selviElviselvielviElviselvi1elviElvisElvis</span><br></pre></td></tr></table></figure>

<p>这是完整的 algOne 函数。</p>
<h3 id="Listing-2"><a href="#Listing-2" class="headerlink" title="Listing 2"></a>Listing 2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">80 func algOne(data []byte, find []byte, repl []byte, output *bytes.Buffer) &#123;</span><br><span class="line"> 81</span><br><span class="line"> 82     &#x2F;&#x2F; Use a bytes Buffer to provide a stream to process.</span><br><span class="line"> 83     input :&#x3D; bytes.NewBuffer(data)</span><br><span class="line"> 84</span><br><span class="line"> 85     &#x2F;&#x2F; The number of bytes we are looking for.</span><br><span class="line"> 86     size :&#x3D; len(find)</span><br><span class="line"> 87</span><br><span class="line"> 88     &#x2F;&#x2F; Declare the buffers we need to process the stream.</span><br><span class="line"> 89     buf :&#x3D; make([]byte, size)</span><br><span class="line"> 90     end :&#x3D; size - 1</span><br><span class="line"> 91</span><br><span class="line"> 92     &#x2F;&#x2F; Read in an initial number of bytes we need to get started.</span><br><span class="line"> 93     if n, err :&#x3D; io.ReadFull(input, buf[:end]); err !&#x3D; nil &#123;</span><br><span class="line"> 94         output.Write(buf[:n])</span><br><span class="line"> 95         return</span><br><span class="line"> 96     &#125;</span><br><span class="line"> 97</span><br><span class="line"> 98     for &#123;</span><br><span class="line"> 99</span><br><span class="line">100         &#x2F;&#x2F; Read in one byte from the input stream.</span><br><span class="line">101         if _, err :&#x3D; io.ReadFull(input, buf[end:]); err !&#x3D; nil &#123;</span><br><span class="line">102</span><br><span class="line">103             &#x2F;&#x2F; Flush the reset of the bytes we have.</span><br><span class="line">104             output.Write(buf[:end])</span><br><span class="line">105             return</span><br><span class="line">106         &#125;</span><br><span class="line">107</span><br><span class="line">108         &#x2F;&#x2F; If we have a match, replace the bytes.</span><br><span class="line">109         if bytes.Compare(buf, find) &#x3D;&#x3D; 0 &#123;</span><br><span class="line">110             output.Write(repl)</span><br><span class="line">111</span><br><span class="line">112             &#x2F;&#x2F; Read a new initial number of bytes.</span><br><span class="line">113             if n, err :&#x3D; io.ReadFull(input, buf[:end]); err !&#x3D; nil &#123;</span><br><span class="line">114                 output.Write(buf[:n])</span><br><span class="line">115                 return</span><br><span class="line">116             &#125;</span><br><span class="line">117</span><br><span class="line">118             continue</span><br><span class="line">119         &#125;</span><br><span class="line">120</span><br><span class="line">121         &#x2F;&#x2F; Write the front byte since it has been compared.</span><br><span class="line">122         output.WriteByte(buf[0])</span><br><span class="line">123</span><br><span class="line">124         &#x2F;&#x2F; Slice that front byte out.</span><br><span class="line">125         copy(buf, buf[1:])</span><br><span class="line">126     &#125;</span><br><span class="line">127 &#125;</span><br></pre></td></tr></table></figure>

<p>我想知道的是这个函数的性能表现得怎么样，以及它在堆上分配带来什么样的压力。为了这个目的，我们将进行压力测试。</p>
<h2 id="压力测试（Benchmarking）"><a href="#压力测试（Benchmarking）" class="headerlink" title="压力测试（Benchmarking）"></a>压力测试（Benchmarking）</h2><p>这个是我写的压力测试函数，它在内部调用 algOne 函数去处理数据流。</p>
<h3 id="Listing-3"><a href="#Listing-3" class="headerlink" title="Listing 3"></a>Listing 3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">15 func BenchmarkAlgorithmOne(b *testing.B) &#123;</span><br><span class="line">16     var output bytes.Buffer</span><br><span class="line">17     in :&#x3D; assembleInputStream()</span><br><span class="line">18     find :&#x3D; []byte(&quot;elvis&quot;)</span><br><span class="line">19     repl :&#x3D; []byte(&quot;Elvis&quot;)</span><br><span class="line">20</span><br><span class="line">21     b.ResetTimer()</span><br><span class="line">22</span><br><span class="line">23     for i :&#x3D; 0; i &lt; b.N; i++ &#123;</span><br><span class="line">24         output.Reset()</span><br><span class="line">25         algOne(in, find, repl, &amp;output)</span><br><span class="line">26     &#125;</span><br><span class="line">27 &#125;</span><br></pre></td></tr></table></figure>

<p>有这个压力测试函数，我们就可以运行<code>go test</code>并使用<code>-bench</code>，<code>-benchtime</code>和<code>-benchmem</code>选项。</p>
<h3 id="Listing-4"><a href="#Listing-4" class="headerlink" title="Listing 4"></a>Listing 4</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go test -run none -bench AlgorithmOne -benchtime 3s -benchmem</span><br><span class="line">BenchmarkAlgorithmOne-8    	2000000 	     2522 ns&#x2F;op       117 B&#x2F;op  	      2 allocs&#x2F;op</span><br></pre></td></tr></table></figure>

<p>运行完压力测试后，我们可以看到<code>algOne</code>函数分配了两次值，每次分配了 117 个字节。这真的很棒，但我们还需要知道哪行代码造成了分配。为了这个目的，我们需要生成压力测试的分析数据。</p>
<h2 id="性能分析（Profiling）"><a href="#性能分析（Profiling）" class="headerlink" title="性能分析（Profiling）"></a>性能分析（Profiling）</h2><p>为了生成分析数据，我们将再次运行压力测试，但这次为了生成内存检测数据，我们打开 -memprofile 开关。</p>
<h3 id="Listing-5"><a href="#Listing-5" class="headerlink" title="Listing 5"></a>Listing 5</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go test -run none -bench AlgorithmOne -benchtime 3s -benchmem -memprofile mem.out</span><br><span class="line">BenchmarkAlgorithmOne-8        2000000      2570 ns&#x2F;op       117 B&#x2F;op        2 allocs&#x2F;op</span><br></pre></td></tr></table></figure>

<p>一旦压力测试完成，测试工具就会生成两个新的文件。</p>
<h3 id="Listing-6"><a href="#Listing-6" class="headerlink" title="Listing 6"></a>Listing 6</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~&#x2F;code&#x2F;go&#x2F;src&#x2F;...&#x2F;memcpu</span><br><span class="line">$ ls -l</span><br><span class="line">total 9248</span><br><span class="line">-rw-r--r--  1 bill  staff      209 May 22 18:11 mem.out       (NEW)</span><br><span class="line">-rwxr-xr-x  1 bill  staff  2847600 May 22 18:10 memcpu.test   (NEW)</span><br><span class="line">-rw-r--r--  1 bill  staff     4761 May 22 18:01 stream.go</span><br><span class="line">-rw-r--r--  1 bill  staff      880 May 22 14:49 stream_test.go</span><br></pre></td></tr></table></figure>

<p>源码在<code>memcpu</code>目录中，<code>algOne</code>函数在<code>stream.go</code>文件中，压力测试函数在<code>stream_test.go</code>文件中。<br>新生成的文件为<code>mem.out</code>和<code>memcpu.test。mem.out</code>包含分析数据和 <code>memcpu.test</code>文件，以及包含我们查看分析数据时需要访问符号的二进制文件。</p>
<p>有了分析数据和二进制测试文件，我们就可以运行 pprof 工具学习数据分析。</p>
<h3 id="Listing-7"><a href="#Listing-7" class="headerlink" title="Listing 7"></a>Listing 7</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go tool pprof -alloc_space memcpu.test mem.out</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands)</span><br><span class="line">(pprof) _</span><br></pre></td></tr></table></figure>

<p>当分析内存数据时，为了轻而易举地得到我们要的信息，<br>你会想用<code>-alloc_space</code>选项替代默认的<code>-inuse_space</code>选项。这将会向你展示每一次分配发生在哪里，不管你分析数据时它是不是还在内存中。</p>
<p>在<code>（pprof）</code>提示下，我们使用<code>list</code> 命令检查<code>algOne</code>函数。这个命令可以使用正则表达式作为参数找到你要的函数。</p>
<h3 id="Listing-8"><a href="#Listing-8" class="headerlink" title="Listing 8"></a>Listing 8</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(pprof) list algOne</span><br><span class="line">Total: 335.03MB</span><br><span class="line">ROUTINE &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ...&#x2F;memcpu.algOne in code&#x2F;go&#x2F;src&#x2F;...&#x2F;memcpu&#x2F;stream.go</span><br><span class="line"> 335.03MB   335.03MB (flat, cum)   100% of Total</span><br><span class="line">        .          .     78:</span><br><span class="line">        .          .     79:&#x2F;&#x2F; algOne is one way to solve the problem.</span><br><span class="line">        .          .     80:func algOne(data []byte, find []byte, repl []byte, output *bytes.Buffer) &#123;</span><br><span class="line">        .          .     81:</span><br><span class="line">        .          .     82: &#x2F;&#x2F; Use a bytes Buffer to provide a stream to process.</span><br><span class="line"> 318.53MB   318.53MB     83: input :&#x3D; bytes.NewBuffer(data)</span><br><span class="line">        .          .     84:</span><br><span class="line">        .          .     85: &#x2F;&#x2F; The number of bytes we are looking for.</span><br><span class="line">        .          .     86: size :&#x3D; len(find)</span><br><span class="line">        .          .     87:</span><br><span class="line">        .          .     88: &#x2F;&#x2F; Declare the buffers we need to process the stream.</span><br><span class="line">  16.50MB    16.50MB     89: buf :&#x3D; make([]byte, size)</span><br><span class="line">        .          .     90: end :&#x3D; size - 1</span><br><span class="line">        .          .     91:</span><br><span class="line">        .          .     92: &#x2F;&#x2F; Read in an initial number of bytes we need to get started.</span><br><span class="line">        .          .     93: if n, err :&#x3D; io.ReadFull(input, buf[:end]); err !&#x3D; nil || n &lt; end &#123;</span><br><span class="line">        .          .     94:       output.Write(buf[:n])</span><br><span class="line">(pprof) _</span><br></pre></td></tr></table></figure>

<p>基于这次的数据分析，我们现在知道了<code>input</code>，<code>buf</code>数组在堆中分配。<br>因为<code>input</code>是指针变量，分析数据表明<code>input</code>指针变量指定的<code>bytes.Buffer</code>值分配了。<br>我们先关注<code>input</code>内存分配以及弄清楚为啥会被分配。</p>
<p>我们可以假定它被分配是因为调用<code>bytes.NewBuffer</code> 函数时在栈上共享了<code>bytes.Buffer</code>值。<br>然而，存在于<code>flat</code>列（<code>pprof</code>输出的第一列）的值告诉我们值被分配是因为<code>algOne</code>函数共享造成了它的逃逸。</p>
<p>我知道<code>flat</code>列代表在函数中的分配是因为<code>list</code>命令显示<code>Benchmark</code>函数中调用了<code>aglOne</code>。</p>
<h3 id="Listing-9"><a href="#Listing-9" class="headerlink" title="Listing 9"></a>Listing 9</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(pprof) list Benchmark</span><br><span class="line">Total: 335.03MB</span><br><span class="line">ROUTINE &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ...&#x2F;memcpu.BenchmarkAlgorithmOne in code&#x2F;go&#x2F;src&#x2F;...&#x2F;memcpu&#x2F;stream_test.go</span><br><span class="line">        0   335.03MB (flat, cum)   100% of Total</span><br><span class="line">        .          .     18: find :&#x3D; []byte(&quot;elvis&quot;)</span><br><span class="line">        .          .     19: repl :&#x3D; []byte(&quot;Elvis&quot;)</span><br><span class="line">        .          .     20:</span><br><span class="line">        .          .     21: b.ResetTimer()</span><br><span class="line">        .          .     22:</span><br><span class="line">        .   335.03MB     23: for i :&#x3D; 0; i &lt; b.N; i++ &#123;</span><br><span class="line">        .          .     24:       output.Reset()</span><br><span class="line">        .          .     25:       algOne(in, find, repl, &amp;output)</span><br><span class="line">        .          .     26: &#125;</span><br><span class="line">        .          .     27:&#125;</span><br><span class="line">        .          .     28:</span><br><span class="line">(pprof) _</span><br></pre></td></tr></table></figure>

<p>因为在<code>cum</code>列（第二列）只有一个值，这告诉我<code>Benchmark</code>没有直接分配。所有的内存分配都发生在函数调用的循环里。你可以看到这两个<code>list</code>调用的分配次数是匹配的。</p>
<p>我们还是不知道为什么<code>bytes.Buffer</code>值被分配。这时在<code>go build</code>的时候打开<code>-gcflags &quot;-m -m&quot;</code>就派上用场了。分析数据只能告诉你哪些值逃逸，但编译命令可以告诉你为啥。</p>
<h2 id="编译器报告（Compiler-Reporting）"><a href="#编译器报告（Compiler-Reporting）" class="headerlink" title="编译器报告（Compiler Reporting）"></a>编译器报告（Compiler Reporting）</h2><p>让我们看一下编译器关于代码中逃逸分析的判决。</p>
<h3 id="Listing-10"><a href="#Listing-10" class="headerlink" title="Listing 10"></a>Listing 10</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build -gcflags &quot;-m -m&quot;</span><br></pre></td></tr></table></figure>

<p>这个命令产生了一大堆的输出。<br>我们只需要搜索输出中包含<code>stream.go:83</code>，因为<code>stream.go</code>是包含这段代码的文件名并且第 83 行包含<code>bytes.Buffer</code>的值。搜索后我们找到 6 行。</p>
<h3 id="Listing-11"><a href="#Listing-11" class="headerlink" title="Listing 11"></a>Listing 11</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;stream.go:83: inlining call to bytes.NewBuffer func([]byte) *bytes.Buffer &#123; return &amp;bytes.Buffer literal &#125;</span><br><span class="line"></span><br><span class="line">.&#x2F;stream.go:83: &amp;bytes.Buffer literal escapes to heap</span><br><span class="line">.&#x2F;stream.go:83:   from ~r0 (assign-pair) at .&#x2F;stream.go:83</span><br><span class="line">.&#x2F;stream.go:83:   from input (assigned) at .&#x2F;stream.go:83</span><br><span class="line">.&#x2F;stream.go:83:   from input (interface-converted) at .&#x2F;stream.go:93</span><br><span class="line">.&#x2F;stream.go:83:   from input (passed to call[argument escapes]) at .&#x2F;stream.go:93</span><br></pre></td></tr></table></figure>

<p>我们搜索<code>stream.go:83</code>找到的第一行很有趣。</p>
<h3 id="Listing-12"><a href="#Listing-12" class="headerlink" title="Listing 12"></a>Listing 12</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;stream.go:83: inlining call to bytes.NewBuffer func([]byte) *bytes.Buffer &#123; return &amp;bytes.Buffer literal &#125;</span><br></pre></td></tr></table></figure>

<p>可以肯定<code>bytes.Buffer</code>值没有逃逸，因为它传递给了调用栈。这是因为没有调用<code>bytes.NewBuffer</code>，函数内联处理了。</p>
<p>所以这是我写的代码片段：</p>
<h3 id="Listing-13"><a href="#Listing-13" class="headerlink" title="Listing 13"></a>Listing 13</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">83     input :&#x3D; bytes.NewBuffer(data)</span><br></pre></td></tr></table></figure>

<p>因为编译器选择内联<code>bytes.NewBuffer</code>函数调用，我写的代码被转成：</p>
<h3 id="Listing-14"><a href="#Listing-14" class="headerlink" title="Listing 14"></a>Listing 14</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input :&#x3D; &amp;bytes.Buffer&#123;buf: data&#125;</span><br></pre></td></tr></table></figure>

<p>这意味着<code>algOne</code>函数直接构造<code>bytes.Buffer</code>值。那么，现在的问题是什么造成了值从<code>algOne</code>栈帧中逃逸？答案在我们搜索结果中的另外 5 行。</p>
<h3 id="Listing-15"><a href="#Listing-15" class="headerlink" title="Listing 15"></a>Listing 15</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;stream.go:83: &amp;bytes.Buffer literal escapes to heap</span><br><span class="line">.&#x2F;stream.go:83:   from ~r0 (assign-pair) at .&#x2F;stream.go:83</span><br><span class="line">.&#x2F;stream.go:83:   from input (assigned) at .&#x2F;stream.go:83</span><br><span class="line">.&#x2F;stream.go:83:   from input (interface-converted) at .&#x2F;stream.go:93</span><br><span class="line">.&#x2F;stream.go:83:   from input (passed to call[argument escapes]) at .&#x2F;stream.go:93</span><br></pre></td></tr></table></figure>

<p>这几行告诉我们代码中的第 93 行造成了逃逸。<code>input</code>变量被赋值给一个接口变量。</p>
<h2 id="接口（Interfaces）"><a href="#接口（Interfaces）" class="headerlink" title="接口（Interfaces）"></a>接口（Interfaces）</h2><p>我完全不记得在代码中将值赋给了接口变量。然而，如果你看到 93 行，就可以非常清楚地看到发生了什么。</p>
<h3 id="Listing-16"><a href="#Listing-16" class="headerlink" title="Listing 16"></a>Listing 16</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">93     if n, err :&#x3D; io.ReadFull(input, buf[:end]); err !&#x3D; nil &#123;</span><br><span class="line">94         output.Write(buf[:n])</span><br><span class="line">95         return</span><br><span class="line">96     &#125;</span><br></pre></td></tr></table></figure>

<p><code>io.ReadFull</code>调用造成了接口赋值。如果你看了<code>io.ReadFull</code>函数的定义，你可以看到一个接口类型是如何接收<code>input</code>值。</p>
<h3 id="Listing-17"><a href="#Listing-17" class="headerlink" title="Listing 17"></a>Listing 17</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Reader interface &#123;</span><br><span class="line">      Read(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func ReadFull(r Reader, buf []byte) (n int, err error) &#123;</span><br><span class="line">      return ReadAtLeast(r, buf, len(buf))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传递<code>bytes.Buffer</code>地址到调用栈，在<code>Reader</code>接口变量中存储会造成一次逃逸。<br>现在我们知道使用接口变量是需要开销的：分配和重定向。<br>所以，如果没有很明显的使用接口的原因，你可能不想使用接口。<br>下面是我选择在我的代码中是否使用接口的原则。</p>
<p>使用接口的情况：</p>
<ul>
<li>用户<code>API</code>需要提供实现细节的时候。</li>
<li><code>API</code>的内部需要维护多种实现。</li>
<li>可以改变的<code>API</code>部分已经被识别并需要解耦。</li>
<li>不使用接口的情况：</li>
</ul>
<p>为了使用接口而使用接口。</p>
<ul>
<li>推广算法。</li>
<li>当用户可以定义自己的接口时。</li>
<li>现在我们可以问自己，这个算法真的需要<code>io.ReadFull</code>函数吗？答案是否定的，因为<code>bytes.Buffer</code> 类型有一个方法可以供我们使用。使用方法而不是调用一个函数可以防止重新分配内存。</li>
</ul>
<p>让我们修改代码，删除<code>io</code>包，并直接使用<code>Read</code>函数而不是<code>input</code>变量。</p>
<p>修改后的代码删除了<code>io</code>包的调用，为了保留相同的行号，我使用空标志符替代<code>io</code>包的引用。这会允许（没有使用的）库导入的行待在列表中。</p>
<h3 id="Listing-18"><a href="#Listing-18" class="headerlink" title="Listing 18"></a>Listing 18</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> 12 import (</span><br><span class="line"> 13     &quot;bytes&quot;</span><br><span class="line"> 14     &quot;fmt&quot;</span><br><span class="line"> 15     _ &quot;io&quot;</span><br><span class="line"> 16 )</span><br><span class="line"></span><br><span class="line"> 80 func algOne(data []byte, find []byte, repl []byte, output *bytes.Buffer) &#123;</span><br><span class="line"> 81</span><br><span class="line"> 82     &#x2F;&#x2F; Use a bytes Buffer to provide a stream to process.</span><br><span class="line"> 83     input :&#x3D; bytes.NewBuffer(data)</span><br><span class="line"> 84</span><br><span class="line"> 85     &#x2F;&#x2F; The number of bytes we are looking for.</span><br><span class="line"> 86     size :&#x3D; len(find)</span><br><span class="line"> 87</span><br><span class="line"> 88     &#x2F;&#x2F; Declare the buffers we need to process the stream.</span><br><span class="line"> 89     buf :&#x3D; make([]byte, size)</span><br><span class="line"> 90     end :&#x3D; size - 1</span><br><span class="line"> 91</span><br><span class="line"> 92     &#x2F;&#x2F; Read in an initial number of bytes we need to get started.</span><br><span class="line"> 93     if n, err :&#x3D; input.Read(buf[:end]); err !&#x3D; nil || n &lt; end &#123;</span><br><span class="line"> 94         output.Write(buf[:n])</span><br><span class="line"> 95         return</span><br><span class="line"> 96     &#125;</span><br><span class="line"> 97</span><br><span class="line"> 98     for &#123;</span><br><span class="line"> 99</span><br><span class="line">100         &#x2F;&#x2F; Read in one byte from the input stream.</span><br><span class="line">101         if _, err :&#x3D; input.Read(buf[end:]); err !&#x3D; nil &#123;</span><br><span class="line">102</span><br><span class="line">103             &#x2F;&#x2F; Flush the reset of the bytes we have.</span><br><span class="line">104             output.Write(buf[:end])</span><br><span class="line">105             return</span><br><span class="line">106         &#125;</span><br><span class="line">107</span><br><span class="line">108         &#x2F;&#x2F; If we have a match, replace the bytes.</span><br><span class="line">109         if bytes.Compare(buf, find) &#x3D;&#x3D; 0 &#123;</span><br><span class="line">110             output.Write(repl)</span><br><span class="line">111</span><br><span class="line">112             &#x2F;&#x2F; Read a new initial number of bytes.</span><br><span class="line">113             if n, err :&#x3D; input.Read(buf[:end]); err !&#x3D; nil || n &lt; end &#123;</span><br><span class="line">114                 output.Write(buf[:n])</span><br><span class="line">115                 return</span><br><span class="line">116             &#125;</span><br><span class="line">117</span><br><span class="line">118             continue</span><br><span class="line">119         &#125;</span><br><span class="line">120</span><br><span class="line">121         &#x2F;&#x2F; Write the front byte since it has been compared.</span><br><span class="line">122         output.WriteByte(buf[0])</span><br><span class="line">123</span><br><span class="line">124         &#x2F;&#x2F; Slice that front byte out.</span><br><span class="line">125         copy(buf, buf[1:])</span><br><span class="line">126     &#125;</span><br><span class="line">127 &#125;</span><br></pre></td></tr></table></figure>

<p>修改后我们执行压力测试，可以看到<code>bytes.Buffer 的</code>分配消失了。</p>
<h3 id="Listing-19"><a href="#Listing-19" class="headerlink" title="Listing 19"></a>Listing 19</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go test -run none -bench AlgorithmOne -benchtime 3s -benchmem -memprofile mem.out</span><br><span class="line">BenchmarkAlgorithmOne-8        2000000      1814 ns&#x2F;op         5 B&#x2F;op        1 allocs&#x2F;op</span><br></pre></td></tr></table></figure>

<p>我们可以看到大约 29% 的性能提升。代码从<code>2570 ns/op</code>降到<code>1814 ns/op</code>。解决了这个问题，我们现在可以关注<code>buf</code>切片数组。如果再次使用测试代码生成分析数据，我们应该能够识别到造成剩下的分配的原因。</p>
<h3 id="Listing-20"><a href="#Listing-20" class="headerlink" title="Listing 20"></a>Listing 20</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ go tool pprof -alloc_space memcpu.test mem.out</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands)</span><br><span class="line">(pprof) list algOne</span><br><span class="line">Total: 7.50MB</span><br><span class="line">ROUTINE &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ...&#x2F;memcpu.BenchmarkAlgorithmOne in code&#x2F;go&#x2F;src&#x2F;...&#x2F;memcpu&#x2F;stream_test.go</span><br><span class="line">     11MB       11MB (flat, cum)   100% of Total</span><br><span class="line">        .          .     84:</span><br><span class="line">        .          .     85: &#x2F;&#x2F; The number of bytes we are looking for.</span><br><span class="line">        .          .     86: size :&#x3D; len(find)</span><br><span class="line">        .          .     87:</span><br><span class="line">        .          .     88: &#x2F;&#x2F; Declare the buffers we need to process the stream.</span><br><span class="line">     11MB       11MB     89: buf :&#x3D; make([]byte, size)</span><br><span class="line">        .          .     90: end :&#x3D; size - 1</span><br><span class="line">        .          .     91:</span><br><span class="line">        .          .     92: &#x2F;&#x2F; Read in an initial number of bytes we need to get started.</span><br><span class="line">        .          .     93: if n, err :&#x3D; input.Read(buf[:end]); err !&#x3D; nil || n &lt; end &#123;</span><br><span class="line">        .          .     94:       output.Write(buf[:n])</span><br></pre></td></tr></table></figure>

<p>只剩下 89 行所示，对数组切片的分配。</p>
<h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>想知道造成<code>buf</code>数组切片的分配的原因？让我们再次运行<code>go build</code>，并使用<code>-gcflags &quot;-m -m&quot;</code>选项并搜索<code>stream.go:89</code>。</p>
<h3 id="Listing-21"><a href="#Listing-21" class="headerlink" title="Listing 21"></a>Listing 21</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go build -gcflags &quot;-m -m&quot;</span><br><span class="line">.&#x2F;stream.go:89: make([]byte, size) escapes to heap</span><br><span class="line">.&#x2F;stream.go:89: from make([]byte, size) (too large for stack) at .&#x2F;stream.go:89</span><br></pre></td></tr></table></figure>

<p>报告显示，对于栈来说，数组太大了。这个信息误导了我们。并不是说底层的数组太大，而是编译器在编译时并不知道数组的大小。</p>
<p>值只有在编译器编译时知道其大小才会将它分配到栈中。这是因为每个函数的栈帧大小是在编译时计算的。如果编译器不知道其大小，就只会在堆中分配。</p>
<p>为了验证（我们的想法），我们将值硬编码为 5，然后再次运行压力测试。</p>
<h3 id="Listing-22"><a href="#Listing-22" class="headerlink" title="Listing 22"></a>Listing 22</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">89     buf :&#x3D; make([]byte, 5)</span><br></pre></td></tr></table></figure>

<p>这一次我们运行压力测试，分配消失了。</p>
<h3 id="Listing-23"><a href="#Listing-23" class="headerlink" title="Listing 23"></a>Listing 23</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go test -run none -bench AlgorithmOne -benchtime 3s -benchmem</span><br><span class="line">BenchmarkAlgorithmOne-8    3000000      1720 ns&#x2F;op        0 B&#x2F;op        0 allocs&#x2F;op</span><br></pre></td></tr></table></figure>

<p>如果你再看一下编译器报告，你会发现没有需要逃逸处理的。</p>
<h3 id="Listing-24"><a href="#Listing-24" class="headerlink" title="Listing 24"></a>Listing 24</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go build -gcflags &quot;-m -m&quot;</span><br><span class="line">.&#x2F;stream.go:83: algOne &amp;bytes.Buffer literal does not escape</span><br><span class="line">.&#x2F;stream.go:89: algOne make([]byte, 5) does not escape</span><br></pre></td></tr></table></figure>

<p>很明显我们无法确定切片的大小，所以我们在算法中需要一次分配。</p>
<h2 id="分配和性能（Allocation-and-Performance）"><a href="#分配和性能（Allocation-and-Performance）" class="headerlink" title="分配和性能（Allocation and Performance）"></a>分配和性能（Allocation and Performance）</h2><p>比较一下我们在重构过程中，每次提升的性能。</p>
<h3 id="Listing-25"><a href="#Listing-25" class="headerlink" title="Listing 25"></a>Listing 25</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Before any optimization</span><br><span class="line">BenchmarkAlgorithmOne-8        2000000      2570 ns&#x2F;op       117 B&#x2F;op        2 allocs&#x2F;op</span><br><span class="line"></span><br><span class="line">Removing the bytes.Buffer allocation</span><br><span class="line">BenchmarkAlgorithmOne-8     2000000      1814 ns&#x2F;op         5 B&#x2F;op        1 allocs&#x2F;op</span><br><span class="line"></span><br><span class="line">Removing the backing array allocation</span><br><span class="line">BenchmarkAlgorithmOne-8     3000000      1720 ns&#x2F;op         0 B&#x2F;op        0 allocs&#x2F;op</span><br></pre></td></tr></table></figure>

<p>删除掉<code>bytes.Buffer</code>里面的（重新）内存分配，我们获得了大约 29% 的性能提升，删除掉所有的分配，我们能获得大约 33% 的性能提升。内存分配是应用程序性能影响因素之一。</p>
<h2 id="结论（Conclusion）"><a href="#结论（Conclusion）" class="headerlink" title="结论（Conclusion）"></a>结论（Conclusion）</h2><p>Go 拥有一些神奇的工具使你能了解编译器作出的跟逃逸分析相关的一些决定。基于这些信息，你可以通过重构代码使得值存在于栈中而不需要在（被重新分配到）堆中。你不是想去掉所有软件中所有的内存（再）分配，而是想最小化这些分配。</p>
<p>这就是说，写程序时永远不要把性能作为第一优先级，因为你并不想（在写程序时）一直猜测性能。写正确的代码才是你第一优先级。这意味着，我们首先要关注的是完整性、可读性和简单性。一旦有了可以运行的程序，才需要确定程序是否足够快。假如程序不够快，那么使用语言提供的工具来查找和解决性能问题。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/26/Go/Translation/GoLanguageMechanicsOnEscapeAnalysis/" rel="prev" title="GoLanguageMechanicsOnEscapeAnalysis">
      <i class="fa fa-chevron-left"></i> GoLanguageMechanicsOnEscapeAnalysis
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/26/Go/Translation/GoLanguageMechanicsOnStacksAndPointers/" rel="next" title="GoLanguageMechanicsOnStacksAndPointers">
      GoLanguageMechanicsOnStacksAndPointers <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Language-Mechanics-On-Memory-Profiling"><span class="nav-number">1.</span> <span class="nav-text">Language Mechanics On Memory Profiling</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍（Introduction）"><span class="nav-number">1.2.</span> <span class="nav-text">介绍（Introduction）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序（The-Program）"><span class="nav-number">1.3.</span> <span class="nav-text">程序（The Program）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">Listing 1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-2"><span class="nav-number">1.3.2.</span> <span class="nav-text">Listing 2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#压力测试（Benchmarking）"><span class="nav-number">1.4.</span> <span class="nav-text">压力测试（Benchmarking）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-3"><span class="nav-number">1.4.1.</span> <span class="nav-text">Listing 3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-4"><span class="nav-number">1.4.2.</span> <span class="nav-text">Listing 4</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能分析（Profiling）"><span class="nav-number">1.5.</span> <span class="nav-text">性能分析（Profiling）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-5"><span class="nav-number">1.5.1.</span> <span class="nav-text">Listing 5</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-6"><span class="nav-number">1.5.2.</span> <span class="nav-text">Listing 6</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-7"><span class="nav-number">1.5.3.</span> <span class="nav-text">Listing 7</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-8"><span class="nav-number">1.5.4.</span> <span class="nav-text">Listing 8</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-9"><span class="nav-number">1.5.5.</span> <span class="nav-text">Listing 9</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译器报告（Compiler-Reporting）"><span class="nav-number">1.6.</span> <span class="nav-text">编译器报告（Compiler Reporting）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-10"><span class="nav-number">1.6.1.</span> <span class="nav-text">Listing 10</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-11"><span class="nav-number">1.6.2.</span> <span class="nav-text">Listing 11</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-12"><span class="nav-number">1.6.3.</span> <span class="nav-text">Listing 12</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-13"><span class="nav-number">1.6.4.</span> <span class="nav-text">Listing 13</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-14"><span class="nav-number">1.6.5.</span> <span class="nav-text">Listing 14</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-15"><span class="nav-number">1.6.6.</span> <span class="nav-text">Listing 15</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口（Interfaces）"><span class="nav-number">1.7.</span> <span class="nav-text">接口（Interfaces）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-16"><span class="nav-number">1.7.1.</span> <span class="nav-text">Listing 16</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-17"><span class="nav-number">1.7.2.</span> <span class="nav-text">Listing 17</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-18"><span class="nav-number">1.7.3.</span> <span class="nav-text">Listing 18</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-19"><span class="nav-number">1.7.4.</span> <span class="nav-text">Listing 19</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-20"><span class="nav-number">1.7.5.</span> <span class="nav-text">Listing 20</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈帧"><span class="nav-number">1.8.</span> <span class="nav-text">栈帧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-21"><span class="nav-number">1.8.1.</span> <span class="nav-text">Listing 21</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-22"><span class="nav-number">1.8.2.</span> <span class="nav-text">Listing 22</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-23"><span class="nav-number">1.8.3.</span> <span class="nav-text">Listing 23</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-24"><span class="nav-number">1.8.4.</span> <span class="nav-text">Listing 24</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分配和性能（Allocation-and-Performance）"><span class="nav-number">1.9.</span> <span class="nav-text">分配和性能（Allocation and Performance）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Listing-25"><span class="nav-number">1.9.1.</span> <span class="nav-text">Listing 25</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结论（Conclusion）"><span class="nav-number">1.10.</span> <span class="nav-text">结论（Conclusion）</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hei"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Hei</p>
  <div class="site-description" itemprop="description">心里有梦，眼里有光</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hei6775" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hei6775" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/8523015/hey6775" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;8523015&#x2F;hey6775" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
