<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="The Behavior Of ChannelsAuthor: William KennedyOctober 24, 2017  原文地址 ：The Behavior Of Channels Introduction当我第一次开始使用 Go 的通道时，我错误地将通道视为数据结构。我将通道视为队列，在 goroutines 之间提供自动同步访问。这种结构性的理解使我编写了许多糟糕而复杂的并发代码。">
<meta property="og:type" content="article">
<meta property="og:title" content="GoBehaviorOfChannels">
<meta property="og:url" content="http://yoursite.com/2020/06/25/Go/Translation/GoBehaviorOfChannels/index.html">
<meta property="og:site_name" content="hei">
<meta property="og:description" content="The Behavior Of ChannelsAuthor: William KennedyOctober 24, 2017  原文地址 ：The Behavior Of Channels Introduction当我第一次开始使用 Go 的通道时，我错误地将通道视为数据结构。我将通道视为队列，在 goroutines 之间提供自动同步访问。这种结构性的理解使我编写了许多糟糕而复杂的并发代码。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/06/25/Go/Translation/GoBehaviorOfChannels/86_guarantee_of_delivery.png">
<meta property="og:image" content="http://yoursite.com/2020/06/25/Go/Translation/GoBehaviorOfChannels/86_state.png">
<meta property="og:image" content="http://yoursite.com/2020/06/25/Go/Translation/GoBehaviorOfChannels/86_signaling_with_data.png">
<meta property="og:image" content="http://yoursite.com/2020/06/25/Go/Translation/GoBehaviorOfChannels/86_signaling_without_data.png">
<meta property="article:published_time" content="2020-06-25T14:22:56.000Z">
<meta property="article:modified_time" content="2020-06-26T06:58:40.605Z">
<meta property="article:author" content="Hei">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/06/25/Go/Translation/GoBehaviorOfChannels/86_guarantee_of_delivery.png">

<link rel="canonical" href="http://yoursite.com/2020/06/25/Go/Translation/GoBehaviorOfChannels/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>GoBehaviorOfChannels | hei</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hei</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/25/Go/Translation/GoBehaviorOfChannels/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Hei">
      <meta itemprop="description" content="心里有梦，眼里有光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          GoBehaviorOfChannels
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-25 22:22:56" itemprop="dateCreated datePublished" datetime="2020-06-25T22:22:56+08:00">2020-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-26 14:58:40" itemprop="dateModified" datetime="2020-06-26T14:58:40+08:00">2020-06-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="The-Behavior-Of-Channels"><a href="#The-Behavior-Of-Channels" class="headerlink" title="The Behavior Of Channels"></a>The Behavior Of Channels</h1><p align="right">Author: William KennedyOctober 24, 2017</p>

<p>原文地址 ：<a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html" target="_blank" rel="noopener">The Behavior Of Channels</a></p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>当我第一次开始使用 Go 的通道时，我错误地将通道视为数据结构。<br>我将通道视为队列，在 goroutines 之间提供自动同步访问。<br>这种结构性的理解使我编写了许多糟糕而复杂的并发代码。</p>
<a id="more"></a>

<p>我随着时间的推移了解到，最好忘记通道的结构，转而关注他们的行为方式。<br>所以现在谈到通道，我想到一件事：信号(signaling)。<br>一个通道允许一个<code>goroutine</code>向另一个关于特定事件的<code>goroutine</code>发出信号。<br>信号应该是您使用通道来做的事情的核心。<br>将通道视为信号机制将允许您使用定义明确且更精确的行为编写更好的代码。</p>
<p>要了解信号如何工作，我们必须了解其三个属性：</p>
<ul>
<li><p>Guarantee Of Delivery</p>
</li>
<li><p>State</p>
</li>
<li><p>With or Without Data</p>
</li>
</ul>
<p>这三个属性共同构成了围绕信号传递的设计理念。<br>在我讨论这些属性之后，我将提供一些代码示例来演示应用这些属性的信号。</p>
<h2 id="Guarantee-Of-Delivery"><a href="#Guarantee-Of-Delivery" class="headerlink" title="Guarantee Of Delivery"></a>Guarantee Of Delivery</h2><p>传递保障基于一个问题：“我是否需要保障已收到特定<code>goroutine</code>发送的信号？”</p>
<p>换句话说，在 Listing 1 中给出了这个例子：</p>
<h4 id="Listing-1"><a href="#Listing-1" class="headerlink" title="Listing 1"></a>Listing 1</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="number">02</span>     p := &lt;-ch <span class="comment">// Receive</span></span><br><span class="line"><span class="number">03</span> &#125;()</span><br><span class="line"><span class="number">04</span></span><br><span class="line"><span class="number">05</span> ch &lt;- <span class="string">"paper"</span> <span class="comment">// Send</span></span><br></pre></td></tr></table></figure>

<p>发送<code>goroutine</code>是否需要保证通过 02 行的<code>goroutine</code>接收通过 05 行发送的信号才能继续前进？</p>
<p>根据这个问题的答案，您将知道要使用的两种类型的通道中的哪一种：无缓冲或缓冲。每个通道都围绕传递保障提供不同的行为。</p>
<h4 id="Figure-1-Guarantee-Of-Delivery"><a href="#Figure-1-Guarantee-Of-Delivery" class="headerlink" title="Figure 1 : Guarantee Of Delivery"></a>Figure 1 : Guarantee Of Delivery</h4><p><img src="/2020/06/25/Go/Translation/GoBehaviorOfChannels/86_guarantee_of_delivery.png" alt="86_guarantee_of_delivery.png"></p>
<p>保障是重要的，如果你不这么认为，我有很多相关的东西想要卖给你。<br>当然，我只是开个玩笑，但是当你没有生命保障时，你不会感到紧张吗？<br>在编写并发软件时，充分了解您是否需要保障是至关重要的。<br>随着我们的继续，您将学习如何决定。</p>
<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>通道的行为直接受其当前状态的影响。通道的状态可以是 <code>nil</code>，<code>open</code> 或 <code>closed</code>。</p>
<p>下面的 Listing 2 显示了如何在这三种状态中声明或放置通道。</p>
<h4 id="Listing-2"><a href="#Listing-2" class="headerlink" title="Listing 2"></a>Listing 2</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ** nil channel</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A channel is in a nil state when it is declared to its zero value</span></span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A channel can be placed in a nil state by explicitly setting it to nil.</span></span><br><span class="line">ch = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ** open channel</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A channel is in a open state when it’s made using the built-in function make.</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ** closed channel</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A channel is in a closed state when it’s closed using the built-in function close.</span></span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>状态确定发送和接收操作的行为方式。</p>
<p>信号通过信道发送和接收。不要说<code>read/write</code>，因为通道不提供 <code>I / O</code>.</p>
<h4 id="Figure-2-State"><a href="#Figure-2-State" class="headerlink" title="Figure 2 : State"></a>Figure 2 : State</h4><p><img src="/2020/06/25/Go/Translation/GoBehaviorOfChannels/86_state.png" alt="86_state.png"></p>
<p>当通道处于<code>nil</code>状态时，通道上尝试的任何发送或接收都将导致阻塞。当通道处于<code>open</code>状态时，可以发送和接收信号。当通道处于<code>closed</code>状态时，不再能够发送信号，但仍然可以接收信号。</p>
<p>这些状态将为您遇到的不同情况提供所需的不同行为。将<strong>State</strong>与<strong>Guarantee Of Delivery</strong>相结合时，您可以开始分析由于您的设计选择而产生的成本/收益。在许多情况下，您还可以通过阅读代码快速发现<code>Bug</code>，因为您了解通道的行为方式。</p>
<h2 id="With-and-Without-Data"><a href="#With-and-Without-Data" class="headerlink" title="With and Without Data"></a>With and Without Data</h2><p>需要考虑的最后一个信号属性是您是否需要使用或不使用数据发送信号。</p>
<p>您通过在通道上执行发送来发送数据信号。</p>
<h4 id="Listing-3"><a href="#Listing-3" class="headerlink" title="Listing 3"></a>Listing 3</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- &quot;paper&quot;</span><br></pre></td></tr></table></figure>

<p>当你需要发送带有数据的信号时通常是因为：</p>
<ul>
<li>一个<code>goroutine</code>被通知开始一项新任务。</li>
<li>一个<code>goroutine</code>需要返回结果</li>
</ul>
<p>你可以通过关闭通道来发送没有数据的信号。</p>
<h4 id="Listing-4"><a href="#Listing-4" class="headerlink" title="Listing 4"></a>Listing 4</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(ch)</span><br></pre></td></tr></table></figure>

<p>当你发送没有数据的信号时，通常是因为：</p>
<ul>
<li>一个<code>goroutine</code>被通知停止它正在做的事情。</li>
<li>一个<code>goroutine</code>报告说他们没有结果。</li>
<li>一个<code>goroutine</code>通知它已经处理完并且准备结束，销毁。</li>
</ul>
<p>这些规则有例外，但这些是主要用例以及我们将在本文中关注的用例。我会认为这些规则的例外是初始的代码味道。</p>
<h3 id="Signaling-With-Data"><a href="#Signaling-With-Data" class="headerlink" title="Signaling With Data"></a>Signaling With Data</h3><h4 id="Figure-3-Signaling-With-Data"><a href="#Figure-3-Signaling-With-Data" class="headerlink" title="Figure 3 : Signaling With Data"></a>Figure 3 : Signaling With Data</h4><p><img src="/2020/06/25/Go/Translation/GoBehaviorOfChannels/86_signaling_with_data.png" alt="86_signaling_with_data.png"></p>
<p>这三个通道分别是<code>Unbuffered</code>,<code>Buffered &gt;1</code> or <code>Buffered =1</code>.</p>
<ul>
  <li>
    <b>Guarantee</b>
    <ul>
        <li>无缓冲通道为您提供发送后必须接受的保证</li>
        <li>Because the Receive of the signal <b>Happens Before</b> the Send of the signal completes.</li>
    </ul>
  </li>

  <li><b>No Guarantee</b>
      <ul>
        <li>A <b>Buffered</b> channel of size >1 gives you <b>No Guarantee</b> that a signal being sent has been received.</li>
        <li>Because the Send of the signal <b>Happens Before</b> the Receive of the signal completes.</li>
    </ul>
  </li>
  <li><b>Delayed Guarantee</b>
        <ul>
        <li>A <b>Buffered</b> channel of size =1 gives you a <b>Delayed Guarantee</b>. It can guarantee that the previous signal that was sent has been received.</li>
        <li>Because the <b>Receive</b> of the First Signal, <b>Happens Before</b> the Send of the Second Signal completes.</li>
    </ul>
    </li>
</ul>

<p>缓冲区的大小绝不能是随机数，必须始终针对某些明确定义的约束进行计算。<br>计算中没有无穷大，无论是时间还是空间，一切都必须有一些明确的约束。</p>
<h3 id="Signaling-Without-Data"><a href="#Signaling-Without-Data" class="headerlink" title="Signaling Without Data"></a>Signaling Without Data</h3><p>没有数据的信号主要用于取消。<br>它允许一个<code>goroutine</code>发出信号通知另一个<code>goroutine</code>取消他们正在做的事情并继续前进。取消可以使用无缓冲和缓冲通道来实现，但是当没有数据将被发送时使用缓冲通道是代码味道。</p>
<h4 id="Figure-4-Signaling-Without-Data"><a href="#Figure-4-Signaling-Without-Data" class="headerlink" title="Figure 4 : Signaling Without Data"></a>Figure 4 : Signaling Without Data</h4><p><img src="/2020/06/25/Go/Translation/GoBehaviorOfChannels/86_signaling_without_data.png" alt="86_signaling_without_data.png"></p>
<p>内置函数 close 用于在没有数据的情况下发出信号。<br>如上面<code>State</code>部分所述，您仍然可以在已关闭的通道上接收信号。<br>实际上，封闭通道上的任何接收都不会阻塞，并且接收操作总是返回。</p>
<p>在大多数情况下，您希望使用标准库<code>context</code>包来实现没有数据的信号。<br><code>context</code>包使用下面的<code>Unbuffered</code>通道用于信号，内置函数接近信号而没有数据。</p>
<p>如果您选择使用自己的通道进行取消，而不是<code>context</code>包，则您的通道应为<code>chan struct {}</code>类型。这是<code>zero-space</code>，用于表示这是用于发信号的惯用方式。</p>
<h2 id="Scenarios"><a href="#Scenarios" class="headerlink" title="Scenarios"></a>Scenarios</h2><p>有了这些属性，进一步了解它们在实践中如何工作的最佳方法是运行一系列代码方案。<br>当我在阅读和编写基于通道的代码时，我喜欢将 goroutines 视为人。<br>这种可视化确实很有帮助，我将在下面使用它作为辅助。</p>
<h3 id="Signal-With-Data-Guarantee-Unbuffered-Channels"><a href="#Signal-With-Data-Guarantee-Unbuffered-Channels" class="headerlink" title="Signal With Data - Guarantee - Unbuffered Channels"></a>Signal With Data - Guarantee - Unbuffered Channels</h3><p>当您需要知道已收到正在发送的信号时，会出现两种情况。这些是等待任务和等待结果。</p>
<h4 id="Scenario-1-Wait-For-Task"><a href="#Scenario-1-Wait-For-Task" class="headerlink" title="Scenario 1 - Wait For Task"></a>Scenario 1 - Wait For Task</h4><p>假设你成为一名经理并雇用一名新员工。在这种情况下，您希望新员工执行任务，但他们需要等到您准备好之后。这是因为你需要在它们开始之前给它们一张纸。</p>
<h4 id="Listing-5"><a href="#Listing-5" class="headerlink" title="Listing 5"></a>Listing 5</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> func waitForTask() &#123;</span><br><span class="line">    ch :&#x3D; make(chan string)</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        p :&#x3D; &lt;-ch</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; Employee performs work here.</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; Employee is done and free to go.</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">   time.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)</span><br><span class="line"></span><br><span class="line">   ch &lt;- &quot;paper&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Listing 5 的第 02 行，创建了一个<code>Unbuffered</code>通道，其中包含字符串数据作为随信号一起发送的属性。然后在第 04 行，雇佣一名员工并告诉他在工作前等待 05 号线上的信号。第 05 行是通道接收，导致员工在等待您将要发送的<code>paper</code>时阻塞。一旦员工收到<code>paper</code>，员工就会完成工作，然后就可以自由地完成工作了。</p>
<p>您作为经理与您的新员工同时工作。因此，在第 04 行雇用员工后，您会发现自己（在第 12 行）正在做您需要做的事情以解除阻塞并向员工发出信号。请注意，不知道准备这张纸需要多长时间才能发送。</p>
<p>最终，您已准备好向员工发出信号。在第 14 行，您执行带有数据的信号，数据就是那张纸。由于正在使用无缓冲通道，因此您可以保证在发送操作完成后员工已收到纸张。接收发生在发送之前。</p>
<p>技术上你所知道的是，当你的通道发送操作完成时，员工有<code>paper</code>。在两个通道操作之后，调度程序可以选择执行它想要的任何语句。由您或员工执行的下一行代码是不确定的。这意味着使用<code>print</code>语句可以欺骗你的事情顺序。</p>
<h4 id="Scenario-2-Wait-For-Result"><a href="#Scenario-2-Wait-For-Result" class="headerlink" title="Scenario 2 - Wait For Result"></a>Scenario 2 - Wait For Result</h4><p>在下一个场景中，情况正好相反。这次您希望新员工在被雇用时立即执行任务，您需要等待他们的工作结果。你需要等待，因为你需要他们的<code>paper</code>才能继续。</p>
<h4 id="Listing-6"><a href="#Listing-6" class="headerlink" title="Listing 6"></a>Listing 6</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func waitForResult() &#123;</span><br><span class="line">    ch :&#x3D; make(chan string)</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        time.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)</span><br><span class="line"></span><br><span class="line">        ch &lt;- &quot;paper&quot;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Employee is done and free to go.</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    p :&#x3D; &lt;-ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在清单 6 的第 02 行，创建了一个<code>Unbuffered</code>通道，其中包含将随信号一起发送字符串数据的属性<br>。然后在第 04 行，雇用一名员工并立即投入工作。在第 04 行雇用员工后，您会发现自己在第 12 行等待<code>paper</code>。</p>
<p>员工在第 05 行完成工作后，他们会通过执行带数据的通道发送将结果发送给您。<br>由于这是一个无缓冲通道，因此接收在发送之前发生，并且保证员工已收到结果。<br>一旦员工获得此保证，他们就可以自由地完成任务。<br>在这种情况下，您不知道雇员完成任务需要多长时间。</p>
<h4 id="Cost-Benefit"><a href="#Cost-Benefit" class="headerlink" title="Cost/Benefit"></a>Cost/Benefit</h4><p>无缓冲通道可确保接收到正在发送的信号。<br>这很棒，但没有什么是免费的。这种保证的成本是未知的延迟。<br>在等待任务方案中，员工不知道发送该文件需要多长时间。<br>在等待结果方案中，您不知道雇员将该结果发送给您的时间有多长。</p>
<h3 id="Signal-With-Data-No-Guarantee-Buffered-Channels-gt-1"><a href="#Signal-With-Data-No-Guarantee-Buffered-Channels-gt-1" class="headerlink" title="Signal With Data - No Guarantee - Buffered Channels &gt;1"></a>Signal With Data - No Guarantee - Buffered Channels &gt;1</h3><p>当您不需要知道已收到正在发送的信号时，这两种情况就会发挥作用：<code>Fan Out</code>and<code>Drop</code>.</p>
<p>缓冲通道具有明确定义的空间，可用于存储正在发送的数据。那么你如何决定你需要多少空间呢？回答这些问题：</p>
<ul>
<li>我是否有完美的定义多少的工作任务需要去完成？</li>
<li>有多少工作？</li>
<li>如果我的员工无法继续执行，我可以放弃任何新工作吗？</li>
<li>多少出色的工作让我有能力？</li>
<li>如果我的程序意外终止，我愿意接受多大程度的风险</li>
<li>在缓冲区中等待的任何内容都将丢失。</li>
</ul>
<p>如果这些问题对您正在建模的行为没有意义，那么使用大于 1 的缓冲通道的代码气味可能是错误的。</p>
<h4 id="Scenario-1-Fan-Out"><a href="#Scenario-1-Fan-Out" class="headerlink" title="Scenario 1 - Fan Out"></a>Scenario 1 - Fan Out</h4><p><code>Fan Out</code>模式允许您针对同时工作的问题抛出明确数量的员工。由于每个任务都有一名员工，因此您确切知道将收到多少报告。您可以确保框中有足够的空间来接收所有这些报告。这样，您的员工无需等待您提交报告。然而，如果他们在同一时间或几乎同时到达盒子，他们每个人都需要轮流将报告放在你的盒子里。</p>
<p>想象一下，你再次担任经理，但这次你雇佣了一个员工队伍。您希望每个员工执行一项单独的任务。当每个员工完成任务时，他们需要向您提供<code>paper</code>，该报告必须放在您桌面上的盒子中。</p>
<h4 id="Listing-7"><a href="#Listing-7" class="headerlink" title="Listing 7"></a>Listing 7</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func fanOut() &#123;</span><br><span class="line">    emps :&#x3D; 20</span><br><span class="line">    ch :&#x3D; make(chan string, emps)</span><br><span class="line"></span><br><span class="line">    for e :&#x3D; 0; e &lt; emps; e++ &#123;</span><br><span class="line">        go func() &#123;</span><br><span class="line">            time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond)</span><br><span class="line">             ch &lt;- &quot;paper&quot;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for emps &gt; 0 &#123;</span><br><span class="line">        p :&#x3D; &lt;-ch</span><br><span class="line">        fmt.Println(p)</span><br><span class="line">        emps--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在清单 7 的第 03 行上，创建了一个缓冲通道，<br>其中包含将随信号一起发送字符串数据的属性。<br>这次使用 20 个缓冲区创建了通道，这要归功于第 02 行声明的 emps 变量。</p>
<p>在 05 至 10 行之间，雇用了 20 名员工，他们立即开始工作。<br>你不知道每个员工要在 07 行上走多长时间。<br>然后在第 08 行，员工发送<code>paper</code>，但这次发送不会阻止等待接收。<br>由于每个员工的方框都有空间，因此通道上的发送仅与可能希望在同一时间或几乎同时发送报告的其他员工竞争。</p>
<p>第 12 到 16 行之间的代码就是你。<br>在这里，您可以等待所有 20 名员工完成工作并发送报告。<br>在第 12 行，您处于循环中，在第 13 行，您将被阻塞在通道接收等待您的报告。<br>收到报告后，报告将打印在第 14 行，并且本地计数器变量将递减以指示员工已完成。</p>
<h4 id="Scenario-2-Drop"><a href="#Scenario-2-Drop" class="headerlink" title="Scenario 2 - Drop"></a>Scenario 2 - Drop</h4><p><code>Drop</code>模式允许您在员工满负荷时放弃工作。<br>这样做的好处是可以继续接受客户端的工作，而不会在接受该工作时施加背压或延迟。<br>这里的关键是知道什么时候你真正有能力，所以你不会低估或过度承诺你将尝试完成的工作量。<br>通常，集成测试或指标是帮助您识别此编号所需的。</p>
<p>想象一下，您再次成为经理，并聘请一名员工完成工作。<br>您有一个您希望员工执行的单独任务。<br>当员工完成任务时，您不必知道他们已完成任务。<br>所有重要的是你是否可以在盒子里放置新的工作。<br>如果您无法执行发送，那么您就知道您的盒子已满，而且员工已达到容量。<br>在这一点上，新工作需要被抛弃，因此事情可以继续发展。</p>
<h4 id="Listing-8"><a href="#Listing-8" class="headerlink" title="Listing 8"></a>Listing 8</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">01 func selectDrop() &#123;</span><br><span class="line">02     const cap &#x3D; 5</span><br><span class="line">03     ch :&#x3D; make(chan string, cap)</span><br><span class="line">04</span><br><span class="line">05     go func() &#123;</span><br><span class="line">06         for p :&#x3D; range ch &#123;</span><br><span class="line">07             fmt.Println(&quot;employee : received :&quot;, p)</span><br><span class="line">08         &#125;</span><br><span class="line">09     &#125;()</span><br><span class="line">10</span><br><span class="line">11     const work &#x3D; 20</span><br><span class="line">12     for w :&#x3D; 0; w &lt; work; w++ &#123;</span><br><span class="line">13         select &#123;</span><br><span class="line">14             case ch &lt;- &quot;paper&quot;:</span><br><span class="line">15                 fmt.Println(&quot;manager : send ack&quot;)</span><br><span class="line">16             default:</span><br><span class="line">17                 fmt.Println(&quot;manager : drop&quot;)</span><br><span class="line">18         &#125;</span><br><span class="line">19     &#125;</span><br><span class="line">20</span><br><span class="line">21     close(ch)</span><br><span class="line">22 &#125;</span><br></pre></td></tr></table></figure>

<p>在 Listing 8 的第 03 行，创建了一个缓冲通道，其中包含将随信号一起发送字符串数据的属性。这次通道创建了 5 个缓冲区，这要归功于 02 行声明的上限常量。</p>
<p>在 05 到 09 行之间，雇用一名员工来处理工作。A 范围用于通道接收。每次收到一个<code>paper</code>，就会在第 07 行处理。</p>
<p>在第 11 行到第 19 行之间，您尝试向员工发送 20 张纸。这次使用 select 语句在第 14 行的第一个 case 中执行<code>send</code>。因为在第 16 行的<code>select</code>中使用了<code>default</code>子句，如果<code>send</code>将要阻塞，因为缓冲区中没有空间，通过执行第 17 行放弃发送。</p>
<p>最后在第 21 行，对通道调用内置函数<code>close</code>。这将在没有数据的情况下向员工发出信号，一旦他们完成指定的工作就可以自由行动。</p>
<h4 id="Cost-Benefit-1"><a href="#Cost-Benefit-1" class="headerlink" title="Cost/Benefit"></a>Cost/Benefit</h4><p>大于 1 的缓冲信道不保证始终接收正在发送的信号。<br>远离这种保证是有益的，这是两个<code>goroutines</code>之间通信的减少或没有延迟。<br>在<code>Fan Out</code>场景中，每个将发送报告的员工都有一个缓冲区。<br>在<code>Drop</code>方案中，缓冲区是针对容量进行测量的，如果达到容量，则会丢弃工作，因此可以继续移动。</p>
<p>在这两个选项中，我们不得不忍受这种缺乏保证，因为延迟的减少更为重要。从零到最小延迟的要求不会对系统的整体逻辑造成问题</p>
<h3 id="Signal-With-Data-Delayed-Guarantee-Buffered-Channel-1"><a href="#Signal-With-Data-Delayed-Guarantee-Buffered-Channel-1" class="headerlink" title="Signal With Data - Delayed Guarantee - Buffered Channel 1"></a>Signal With Data - Delayed Guarantee - Buffered Channel 1</h3><p>当需要知道在发送新信号之前是否已收到先前发送的信号时，“等待任务”方案将起作用。</p>
<h4 id="Scenario-1-Wait-For-Tasks"><a href="#Scenario-1-Wait-For-Tasks" class="headerlink" title="Scenario 1 - Wait For Tasks"></a>Scenario 1 - Wait For Tasks</h4><p>在这种情况下，您有一名新员工，但他们要做的不仅仅是一项任务。<br>你将一个接一个地为他们提供许多任务。<br>但是，他们必须先完成每项任务才能开始新任务。<br>由于它们一次只能处理一项任务，因此在切换工作之间可能存在延迟问题。<br>如果可以减少延迟而不失去员工正在处理下一个任务的保证，那么它可能有所帮助。</p>
<p>这是 1<code>Buffered</code>通道有益的地方。如果一切都以您和员工之间的预期速度运行，那么您都不需要等待另一个。<br>每次发送一个<code>paper</code>时，缓冲区都是空的。每当您的员工完成更多工作时，缓冲区就会满了。它是工作流程的完美对称。</p>
<p>最好的部分就是这个。如果您在任何时候尝试发送一个<code>paper</code>而您不能因为缓冲区已满，您知道您的员工遇到了问题而您就停止了。<br>这是延迟保证的来源。<br>当缓冲区为空并执行发送时，您可以保证您的员工已完成您发送的最后一项工作。<br>如果您执行发送而您不能，则可以保证他们没有。</p>
<h4 id="Listing-9"><a href="#Listing-9" class="headerlink" title="Listing 9"></a>Listing 9</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">01 func waitForTasks() &#123;</span><br><span class="line">02     ch :&#x3D; make(chan string, 1)</span><br><span class="line">03</span><br><span class="line">04     go func() &#123;</span><br><span class="line">05         for p :&#x3D; range ch &#123;</span><br><span class="line">06             fmt.Println(&quot;employee : working :&quot;, p)</span><br><span class="line">07         &#125;</span><br><span class="line">08     &#125;()</span><br><span class="line">09</span><br><span class="line">10     const work &#x3D; 10</span><br><span class="line">11     for w :&#x3D; 0; w &lt; work; w++ &#123;</span><br><span class="line">12         ch &lt;- &quot;paper&quot;</span><br><span class="line">13     &#125;</span><br><span class="line">14</span><br><span class="line">15     close(ch)</span><br><span class="line">16 &#125;</span><br></pre></td></tr></table></figure>

<p>在 Listing 9 的第 02 行，创建了一个大小为 1 的缓冲通道，<br>其中包含字符串数据随信号一起发送的属性。<br>在第 04 至 08 行之间雇用一名雇员来处理工作。<br>A 范围用于通道接收。每次收到一张纸，都会在 06 行上处理。</p>
<p>在第 10 行到第 13 行之间，您开始将您的任务发送给员工。<br>如果您的员工可以尽可能快地运行，那么您的员工之间的延迟就会降低。<br>但是，每次发送都会成功执行，您可以保证您提交的最后一项工作正在进行中。</p>
<p>最后在第 15 行，对通道调用内置函数<code>close</code>。<br>这将向员工发出没有数据的信号，他们已经完成并且可以自由行动。<br>但是，您提交的最后一项工作将在<code>for range</code>终止之前收到（<code>flushed</code>）。</p>
<h3 id="Signal-Without-Data-Context"><a href="#Signal-Without-Data-Context" class="headerlink" title="Signal Without Data - Context"></a>Signal Without Data - Context</h3><p>在最后一个场景中，您将看到如何使用<code>context</code>包中的<code>Context</code>值取消正在运行的<code>goroutine</code>。这一切都可以通过利用关闭的无缓冲通道来执行发送没有数据的信号。</p>
<p>您最后一次是经理，并雇用一名员工完成工作。<br>这次你不愿意等待一段不明的时间让员工完成。<br>您处于离散的最后期限，如果员工没有及时完成，您不愿意等待。</p>
<h4 id="Listing-10"><a href="#Listing-10" class="headerlink" title="Listing 10"></a>Listing 10</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">01 func withTimeout() &#123;</span><br><span class="line">02     duration :&#x3D; 50 * time.Millisecond</span><br><span class="line">03</span><br><span class="line">04     ctx, cancel :&#x3D; context.WithTimeout(context.Background(), duration)</span><br><span class="line">05     defer cancel()</span><br><span class="line">06</span><br><span class="line">07     ch :&#x3D; make(chan string, 1)</span><br><span class="line">08</span><br><span class="line">09     go func() &#123;</span><br><span class="line">10         time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)</span><br><span class="line">11         ch &lt;- &quot;paper&quot;</span><br><span class="line">12     &#125;()</span><br><span class="line">13</span><br><span class="line">14     select &#123;</span><br><span class="line">15     case p :&#x3D; &lt;-ch:</span><br><span class="line">16         fmt.Println(&quot;work complete&quot;, p)</span><br><span class="line">17</span><br><span class="line">18     case &lt;-ctx.Done():</span><br><span class="line">19         fmt.Println(&quot;moving on&quot;)</span><br><span class="line">20     &#125;</span><br><span class="line">21 &#125;</span><br></pre></td></tr></table></figure>

<p>在清单 10 的第 02 行，声明了持续时间值，表示员工必须完成任务的时间。<br>此行在第 04 行上用于创建<code>context.Context</code>值，超时为 50 毫秒。<br><code>context</code>包中的<code>WithTimeout</code>函数返回<code>Context</code>值和取消函数。</p>
<p><code>context</code>包创建一个<code>goroutine</code>，一旦满足持续时间，它将关闭与<code>Context</code>值关联的<code>Unbuffered</code>通道。<br>无论情况如何，您都有责任调用取消功能。<br>这将清除为<code>Context</code>创建的内容。可以多次调用<code>cancel</code>函数。</p>
<p>在第 05 行，一旦该函数终止，取消函数将被推迟执行。<br>在第 07 行创建了一个缓冲通道 1，员工将使用该通道向您发送工作结果<br>。然后在 09 到 12 行雇用员工并立即投入工作。你不知道雇员完成需要多长时间。</p>
<p>在第 14 行到第 20 行之间，您可以使用<code>select</code>语句在两个通道上接收。<br>在第 15 行收到，您等待员工向您发送结果。<br>在第 18 行接收，你等着看<code>context</code>包是否会发出 50 毫秒的信号。<br>您首先收到的信号将是处理过的信号。</p>
<p>此算法的一个重要方面是使用大小为 1 缓冲通道。<br>如果员工没有及时完成，您将继续前进而不向员工发出任何通知。<br>从员工的角度来看，他们总是会在第 11 行向您发送报告，如果您在那里或者没有收到报告，他们就会失明。<br>如果您使用未缓冲的频道，员工将永久阻止尝试向您发送报告（如果您继续前进）。<br>这会造成<code>goroutine</code>泄漏。因此，使用大小为 1 缓冲通道来防止这种情况发生。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>保证，信道状态和发送周围的信号属性对于在使用信道（或并发）时了解和理解是很重要的。<br>它们将指导您实现所编写的并发程序和算法所需的最佳行为。它们将帮助您找到错误并嗅出可能有害的代码。</p>
<p>在这篇文章中，我分享了一些示例程序，展示信号的属性如何在不同的场景中工作。每条规则都有例外，但这些模式是一个很好的基础。</p>
<ul>
<li>使用通道来协调和协调 goroutines。<ul>
<li>专注于信令属性而不是数据共享。</li>
<li>用数据发送信号或不发送数据。</li>
<li>询问它们用于同步对共享状态的访问。 - 有些情况下，渠道可以更简单，但最初的问题。</li>
</ul>
</li>
</ul>
<h3 id="Language-Mechanics"><a href="#Language-Mechanics" class="headerlink" title="Language Mechanics"></a>Language Mechanics</h3><h3 id="Design-Philosophy"><a href="#Design-Philosophy" class="headerlink" title="Design Philosophy"></a>Design Philosophy</h3>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/25/Go/Translation/GoCommands/" rel="prev" title="GoCommands">
      <i class="fa fa-chevron-left"></i> GoCommands
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/26/Go/Translation/GoDesignPhilosophyOnDataAndSemantics/" rel="next" title="GoDesignPhilosophyOnDataAndSemantics">
      GoDesignPhilosophyOnDataAndSemantics <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#The-Behavior-Of-Channels"><span class="nav-number">1.</span> <span class="nav-text">The Behavior Of Channels</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-number">1.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Guarantee-Of-Delivery"><span class="nav-number">1.2.</span> <span class="nav-text">Guarantee Of Delivery</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Listing-1"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">Listing 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Figure-1-Guarantee-Of-Delivery"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">Figure 1 : Guarantee Of Delivery</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#State"><span class="nav-number">1.3.</span> <span class="nav-text">State</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Listing-2"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">Listing 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Figure-2-State"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">Figure 2 : State</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#With-and-Without-Data"><span class="nav-number">1.4.</span> <span class="nav-text">With and Without Data</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Listing-3"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">Listing 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Listing-4"><span class="nav-number">1.4.0.2.</span> <span class="nav-text">Listing 4</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Signaling-With-Data"><span class="nav-number">1.4.1.</span> <span class="nav-text">Signaling With Data</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Figure-3-Signaling-With-Data"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">Figure 3 : Signaling With Data</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Signaling-Without-Data"><span class="nav-number">1.4.2.</span> <span class="nav-text">Signaling Without Data</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Figure-4-Signaling-Without-Data"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">Figure 4 : Signaling Without Data</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Scenarios"><span class="nav-number">1.5.</span> <span class="nav-text">Scenarios</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Signal-With-Data-Guarantee-Unbuffered-Channels"><span class="nav-number">1.5.1.</span> <span class="nav-text">Signal With Data - Guarantee - Unbuffered Channels</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Scenario-1-Wait-For-Task"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">Scenario 1 - Wait For Task</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Listing-5"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">Listing 5</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Scenario-2-Wait-For-Result"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">Scenario 2 - Wait For Result</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Listing-6"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">Listing 6</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cost-Benefit"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">Cost&#x2F;Benefit</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Signal-With-Data-No-Guarantee-Buffered-Channels-gt-1"><span class="nav-number">1.5.2.</span> <span class="nav-text">Signal With Data - No Guarantee - Buffered Channels &gt;1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Scenario-1-Fan-Out"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">Scenario 1 - Fan Out</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Listing-7"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">Listing 7</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Scenario-2-Drop"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">Scenario 2 - Drop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Listing-8"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">Listing 8</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cost-Benefit-1"><span class="nav-number">1.5.2.5.</span> <span class="nav-text">Cost&#x2F;Benefit</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Signal-With-Data-Delayed-Guarantee-Buffered-Channel-1"><span class="nav-number">1.5.3.</span> <span class="nav-text">Signal With Data - Delayed Guarantee - Buffered Channel 1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Scenario-1-Wait-For-Tasks"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">Scenario 1 - Wait For Tasks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Listing-9"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">Listing 9</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Signal-Without-Data-Context"><span class="nav-number">1.5.4.</span> <span class="nav-text">Signal Without Data - Context</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Listing-10"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">Listing 10</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Conclusion"><span class="nav-number">1.6.</span> <span class="nav-text">Conclusion</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Language-Mechanics"><span class="nav-number">1.6.1.</span> <span class="nav-text">Language Mechanics</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Design-Philosophy"><span class="nav-number">1.6.2.</span> <span class="nav-text">Design Philosophy</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hei"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Hei</p>
  <div class="site-description" itemprop="description">心里有梦，眼里有光</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hei6775" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hei6775" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/8523015/hey6775" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;8523015&#x2F;hey6775" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
